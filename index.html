<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Suave.evreact by unipi-itc</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Suave.evreact</h1>
        <p></p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/unipi-itc/Suave.EvReact" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/unipi-itc/Suave.EvReact/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/unipi-itc/Suave.EvReact/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h3>
<a id="suaveevreact" class="anchor" href="#suaveevreact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Suave.EvReact</h3>

<p><a href="http://vslab.github.io/evreact">EvReact</a> is a very lightweight library introducing an event-based orchestrator for reactive programming. In essence you can describe workflows orchestrated by events that advance the workflow and trigger the events associated with its nodes. Suave.EvReact is a very simple adapter for Suave that transforms HTTP requests into events to be
orchestrated by EvReact. It is useful whenever you need a specific sequence in URL invocations and ensure that a URL is
inaccessible in a given state.</p>

<p>Here is a very simple example</p>

<pre><code>open Suave.EvReact

open Suave
open Suave.Http
open Suave.Successful
open Suave.Web
open Suave.EvReact
open EvReact
open EvReact.Expr

// Create the EvReact events associated with URLs
let start = HttpEvent()
let work = HttpEvent()
let stop = HttpEvent()
let status = HttpEvent()

let jobs = ResizeArray&lt;string&gt;()

// chooseEvents is the only combiner currently featured by Suave.EvReact
// The list is (regex, event, default)
// Whenever the regex is matched by Suave the event is fired. 
// The default web part can be overridden by assigining the Result property
// in the event

// In this example we have jobs that are started by accessing /start/id
// You perform some work only if the job is running with /work/id/arg
// You stop the job using /stop/id
let app = chooseEvents 
            [
                ("/start/(\\d+)", start, NO_CONTENT)
                ("/work/(\\d+)/(\\d+)", work, NO_CONTENT)
                ("/stop/(\\d+)", stop, NO_CONTENT)
                ("/status", status, NO_CONTENT)
            ]

// This EvReact net simply react to the status event by printing the list of jobs
let statusReq = !!status.Publish |-&gt; (fun arg -&gt; arg.Result &lt;- OK (System.String.Join("&lt;br/&gt;", jobs)))

// Useful net generator expressing a loop until
let loopUntil terminator body = +( body / terminator ) - never

// The orchestrator used to run the nets
let orch = EvReact.Orchestrator.create()

// When start is received the function gets triggered
let startNet = !!start.Publish |-&gt; (fun arg -&gt;
  // Read the id from the argument
  let id = arg.Match.Groups.[1].Value
  jobs.Add(id)

  // Set the response
  arg.Result &lt;- OK (sprintf "Started job %s" id)

  // The net performing the actual work is triggered only if the id is the one started
  let doWork = (work.Publish %- (fun arg -&gt; arg.Match.Groups.[1].Value = id)) |-&gt; (fun arg -&gt;
    let value = int(arg.Match.Groups.[2].Value)
    arg.Result &lt;- OK ((value + 1).ToString())
  )

  // We get the stop event and only if relates to the current id trigger the stopNet event
  let stopNet = HttpEvent()
  let stopThis = (stop.Publish %- (fun arg -&gt; arg.Match.Groups.[1].Value = id))
                 |-&gt; (fun arg -&gt; arg.Result &lt;- OK(sprintf "Job %s done" id)
                                 jobs.Remove(id) |&gt; ignore 
                                 stopNet.Trigger(arg)
                     )
  // Start a net listening for the stop event
  Expr.start HttpEventArgs.Empty orch stopThis |&gt; ignore

  // Net looping forever unless the stopNet event fires
  let net = (loopUntil [|stopNet.Publish|] doWork)

  // Starts the net
  Expr.start HttpEventArgs.Empty orch net |&gt; ignore
)

// Starts the startNet and statusReq nets looping forever
Expr.start HttpEventArgs.Empty orch (+startNet)
Expr.start HttpEventArgs.Empty orch (+statusReq)

// Starts Suave
startWebServer defaultConfig app
</code></pre>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/unipi-itc">unipi-itc</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
